// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawner.h"
#include "Engine/World.h"
#include "UObject/ConstructorHelpers.h"
#include "Components/SceneComponent.h"
#include "Components/BillboardComponent.h"
#include "MassSpawnerTypes.h"
#include "MassSpawnerSubsystem.h"
#include "MassSimulationSubsystem.h"
#include "EnvironmentQuery/EnvQuery.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityConfigAsset.h"
#include "EngineUtils.h"
#include "Engine/StreamableManager.h"
#include "Engine/AssetManager.h"
#include "MassGameplaySettings.h"
#include "MassSpawnLocationProcessor.h"


namespace UE::MassSpawner
{
	float ScalabilitySpawnDensityMultiplier = 1.f;
	FAutoConsoleVariableRef CVarScalabilitySpawnDensityMultiplier(TEXT("ai.mass.scalability.SpawnDensityMultiplier"), ScalabilitySpawnDensityMultiplier, TEXT("Spawn Density Multiplier, must be set before Mass Spawn Init"), ECVF_Scalability);

#if WITH_EDITOR
	static FAutoConsoleCommandWithWorld ForceSpawningCommand(
	TEXT("ai.mass.ForceSpawn"),
	TEXT("Command to Force Spawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoSpawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ForceDespawningCommand(
	TEXT("ai.mass.ForceDespawn"),
	TEXT("Command to Force Despawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ResetSpawningCommand(
	TEXT("ai.mass.ResetSpawning"),
	TEXT("Command to Force Despawn and Respawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
				Spawner->DoSpawning();
			}
		}
	}));
#endif // WITH_EDITOR
}

AMassSpawner::AMassSpawner()
{
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("SceneComp"));
	RootComponent->Mobility = EComponentMobility::Static;

#if WITH_EDITOR
	SpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT("Sprite"));

	// SpriteComponent can be null for editor builds running "-game|server"
	if (!IsRunningCommandlet() && SpriteComponent != nullptr)
	{
		// Structure to hold one-time initialization
		struct FConstructorStatics
		{
			ConstructorHelpers::FObjectFinderOptional<UTexture2D> IconTextureObject;
			FName MassSpawnerID;
			FText MassSpawnerName;
			FConstructorStatics()
				: IconTextureObject(TEXT("/MassGameplay/S_MassCrowd"))
				, MassSpawnerID(TEXT("MassSpawner"))
				, MassSpawnerName(NSLOCTEXT("SpriteCategory", "MassSpawner", "MassSpawner"))
			{
			}
		};
		static FConstructorStatics ConstructorStatics;
		
		SpriteComponent->Sprite = ConstructorStatics.IconTextureObject.Get();
		SpriteComponent->SetRelativeScale3D(FVector(0.5f, 0.5f, 0.5f));
		SpriteComponent->SpriteInfo.Category = ConstructorStatics.MassSpawnerID;
		SpriteComponent->SpriteInfo.DisplayName = ConstructorStatics.MassSpawnerName;
		SpriteComponent->SetupAttachment(RootComponent);
		SpriteComponent->Mobility = EComponentMobility::Static;
	}
#endif // WITH_EDITOR

	SetCanBeDamaged(false);
	SetActorHiddenInGame(true);

	bAutoSpawnOnBeginPlay = true;
	bOverrideSchematics = false;
}

void AMassSpawner::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		TickSchematicsAdjustHandle = UMassSimulationSubsystem::GetOnAdjustTickSchematics().AddUObject(this, &AMassSpawner::OnAdjustTickSchematics);
	}
}

void AMassSpawner::PostLoad()
{
	Super::PostLoad();

	for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
	{
		if (SpawnPointsGenerator.GeneratorClass)
		{
			SpawnPointsGenerator.GeneratorInstance = NewObject<UMassEntitySpawnPointsGeneratorBase>(this, SpawnPointsGenerator.GeneratorClass);
			SpawnPointsGenerator.GeneratorClass = nullptr;
			MarkPackageDirty();
		}
	}
}

void AMassSpawner::PostRegisterAllComponents()
{
	Super::PostRegisterAllComponents();

	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		UWorld* World = GetWorld();
		check(World);


		// This is a temp fix for streaming levels async loading MassSpawners after UMassSpawnerSubsystem::OnPostWorldInit, 
		// in the long run we are going to need a better system for making sure all the entity templates are registered
		// on the clients before replication of Agents occurs. This is only required to be done for clients.
		if (GEngine->GetNetMode(GetWorld()) == NM_Client)
		{
			UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
			if (MassSpawnerSubsystem)
			{
				RegisterEntityTemplates();
			}
			else
			{
				FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassSpawner::OnPostWorldInit);
			}
		}
	}
}

void AMassSpawner::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)
{
	if (World == GetWorld())
	{
		UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
		check(MassSpawnerSubsystem);

		RegisterEntityTemplates();

		FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
	}
}

void AMassSpawner::BeginDestroy()
{
	FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
	UMassSimulationSubsystem::GetOnAdjustTickSchematics().Remove(TickSchematicsAdjustHandle);

	DoDespawning();
	
	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		StreamingHandle->CancelHandle();
	}

	Super::BeginDestroy();
}

void AMassSpawner::BeginPlay()
{
	check(GEngine);

	Super::BeginPlay();

	const ENetMode NetMode = GEngine->GetNetMode(GetWorld());

	if (bAutoSpawnOnBeginPlay && NetMode != NM_Client)
	{
		const UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());
		if (MassSimulationSubsystem == nullptr || MassSimulationSubsystem->IsSimulationStarted())
		{
			DoSpawning();
		}
		else
		{
			
			SimulationStartedHandle = UMassSimulationSubsystem::GetOnSimulationStarted().AddLambda([this](UWorld* InWorld)
				{
					UWorld* World = GetWorld();

					if (World == InWorld)
					{
						DoSpawning();
					}
				});
		}
	}
}

void AMassSpawner::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	UMassSimulationSubsystem::GetOnSimulationStarted().Remove(SimulationStartedHandle);

	Super::EndPlay(EndPlayReason);
}

#if WITH_EDITOR
void AMassSpawner::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName EntityTypesName = GET_MEMBER_NAME_CHECKED(AMassSpawner, EntityTypes);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property)
	{
		const FName PropName = PropertyChangedEvent.Property->GetFName();
		if (PropName == EntityTypesName)
		{
			// TODO: Should optimize this, i.e. set a dirty flag and update only when needed.
			RegisterEntityTemplates();
		}
	}
}

void AMassSpawner::DEBUG_Spawn()
{
	DoSpawning();
}

void AMassSpawner::DEBUG_Clear()
{
	DoDespawning();
}

#endif // WITH_EDITOR

void AMassSpawner::RegisterEntityTemplates()
{
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->GetConfig().GetOrCreateEntityTemplate(*this, *EntityConfig);
		}
	}
}

void AMassSpawner::DoSpawning()
{
	const int32 SpawnCount = GetSpawnCount();
	if (SpawnCount > 0)
	{
		// no spawn point generators configured. Let user know and fall back to the spawner's location
		if (SpawnPointsGenerators.Num() == 0)
		{
			UE_VLOG_UELOG(this, LogMassSpawner, Warning, TEXT("No Spawn Points Generators configured. Falling back to the MassSpawner\'s location."));
			const FVector SpawnerLocation = GetActorLocation();
			SpawnAtLocations(MakeArrayView(&SpawnerLocation, 1));
			return;
		}

		float TotalProportion = 0.0f;
		for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
		{
			if (SpawnPointsGenerator.GeneratorInstance)
			{
				SpawnPointsGenerator.bPointsGenerated = false;
				TotalProportion += SpawnPointsGenerator.Proportion;
			}
		}

		if (TotalProportion <= 0.0f)
		{
			UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined porportion of all the generator needs to be greater than 0.0f."));
			return;
		}
		// Check if it needs loading
		if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
		{
			// @todo, instead of blindly canceling, we should remember what was asked to load with that handle and compare if more is needed?
			StreamingHandle->CancelHandle();
		}
		TArray<FSoftObjectPath> AssetsToLoad;
		for (const FMassSpawnedEntityType& EntityType : EntityTypes)
		{
			const int32 EntityCount = int32(SpawnCount * EntityType.Proportion / TotalProportion);
			if (EntityCount > 0)

			{
				if (!EntityType.IsLoaded())
				{
					AssetsToLoad.Add(EntityType.EntityConfig.ToSoftObjectPath());
				}
			}
		}

		auto GenerateSpawningPoints = [this, SpawnCount, TotalProportion]()
		{
			int32 SpawnPointCountRemaining = SpawnCount;
			float ProportionRemaining = TotalProportion;
			for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
			{
				// Still needs to call the OnSpawnPointGenerationFinished for Generator we don't want to output Spawn Points for as the system will wait
				// for the bPointsGenerated == true on every Generators before proceeding to the next steps.
				if (SpawnPointsGenerator.Proportion == 0.0f || ProportionRemaining <= 0.0f || SpawnPointCountRemaining <= 0)
				{
					const TArray<FVector> EmptyLoc;
					OnSpawnPointGenerationFinished(EmptyLoc, &SpawnPointsGenerator);
					continue;
				}

				if (SpawnPointsGenerator.GeneratorInstance)
				{
					const float ProportionRatio = FMath::Min(SpawnPointsGenerator.Proportion / ProportionRemaining, 1.0f);
					const int32 SpawnPointCount = FMath::CeilToInt(SpawnPointCountRemaining * ProportionRatio);
					if (SpawnPointCount > 0)
					{
						FFinishedGeneratingSpawnPointsSignature Delegate = FFinishedGeneratingSpawnPointsSignature::CreateUObject(this, &AMassSpawner::OnSpawnPointGenerationFinished, &SpawnPointsGenerator);
						SpawnPointsGenerator.GeneratorInstance->GenerateSpawnPoints(*this, SpawnPointCount, Delegate);
						SpawnPointCountRemaining -= SpawnPointCount;
						ProportionRemaining -= SpawnPointsGenerator.Proportion;
					}
				}
			}
		};
		
		if (AssetsToLoad.Num())
		{
			FStreamableManager& StreamableManager = UAssetManager::GetStreamableManager();
			StreamingHandle = StreamableManager.RequestAsyncLoad(AssetsToLoad, GenerateSpawningPoints);
		}
		else
		{
			GenerateSpawningPoints();
		}
	}
}

void AMassSpawner::OnSpawnPointGenerationFinished(const TArray<FVector>& Locations, FMassSpawnPointGenerator* FinishedGenerator)
{
	AllGeneratedLocations.Append(Locations);

	bool bAllSpawnPointsGenerated = true;
	bool bFoundFinishedGenerator = false;
	for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
	{
		if (&SpawnPointsGenerator == FinishedGenerator)
		{
			SpawnPointsGenerator.bPointsGenerated = true;
			bFoundFinishedGenerator = true;
		}

		bAllSpawnPointsGenerated &= SpawnPointsGenerator.bPointsGenerated;
	}

	checkf(bFoundFinishedGenerator, TEXT("Something went wrong, we are receiving a callback on an unknow spawn point generator"));
	
	if (bAllSpawnPointsGenerated)
	{
		SpawnAtLocations(AllGeneratedLocations);
	}
}

int32 AMassSpawner::GetSpawnCount() const
{
	const float FinalSpawningCountScale = SpawningCountScale * UE::MassSpawner::ScalabilitySpawnDensityMultiplier;
	return int32(FinalSpawningCountScale * Count);
}

void AMassSpawner::SpawnAtLocations(TConstArrayView<FVector> Locations)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to spawn entities"));
		return;
	}

	FMassSpawnAuxData MassSpawnAuxData;
	MassSpawnAuxData.Transforms.Reserve(Locations.Num());
	for (const FVector& Location : Locations)
	{
		FTransform& Transform = MassSpawnAuxData.Transforms.AddDefaulted_GetRef();

		Transform.SetLocation(Location);
	}

#if ENABLE_VISUAL_LOG
	UE_VLOG(this, LogMassSpawner, Log, TEXT("Spawning at %d locations"), Locations.Num());
	if (GetDefault<UMassGameplaySettings>()->bLogSpawnLocations)
	{
		if (FVisualLogEntry* LogEntry = FVisualLogger::Get().GetLastEntryForObject(this))
		{
			FVisualLogShapeElement Element(TEXT(""), FColor::Orange, /*Thickness*/20, LogMassSpawner.GetCategoryName());
			Element.Points.Append(Locations.GetData(), Locations.Num());
			Element.Type = EVisualLoggerShapeElement::SinglePoint;
			Element.Verbosity = ELogVerbosity::Display;
			LogEntry->AddElement(Element);
		}
	}
#endif // ENABLE_VISUAL_LOG

	const int32 SpawnCount = GetSpawnCount();
	if (SpawnCount > 0)
	{
		float TotalProportion = 0.0f;
		for (const FMassSpawnedEntityType& EntityType : EntityTypes)
		{
			TotalProportion += EntityType.Proportion;
		}

		if (TotalProportion <= 0)
		{
			UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined porportion of all the entity types needs to be greater than 0.0f."));
			return;
		}

		AllSpawnedEntities.Reserve(AllSpawnedEntities.Num() + EntityTypes.Num());

		for (const FMassSpawnedEntityType& EntityType : EntityTypes)
		{
			const int32 EntityCount = int32(SpawnCount * EntityType.Proportion / TotalProportion);
			if (EntityCount > 0)
			{
				if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
				{
					const FMassEntityTemplate* EntityTemplate = EntityConfig->GetConfig().GetOrCreateEntityTemplate(*this, *EntityConfig);
					if (EntityTemplate && EntityTemplate->IsValid())
					{
						FSpawnedEntities& SpawnedEntities = AllSpawnedEntities.AddDefaulted_GetRef();
						SpawnedEntities.TemplateID = EntityTemplate->GetTemplateID();
						SpawnerSystem->SpawnEntities(EntityTemplate->GetTemplateID(), EntityCount, FStructView::Make(MassSpawnAuxData)
							, UMassSpawnLocationProcessor::StaticClass(), SpawnedEntities.Entities);
					}
				}
			}
		}
	}
}

void AMassSpawner::DoDespawning()
{
	if (AllSpawnedEntities.IsEmpty())
	{
		return;
	}
	
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn entities"));
		return;
	}

	for (const FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		SpawnerSystem->DestroyEntities(SpawnedEntities.TemplateID, SpawnedEntities.Entities);
	}
	AllSpawnedEntities.Reset();
}

bool AMassSpawner::DespawnEntity(const FMassEntityHandle Entity)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn a single entity"));
		return false;
	}

	for (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		const int32 Index = SpawnedEntities.Entities.Find(Entity);
		if (Index != INDEX_NONE)
		{
			SpawnerSystem->DestroyEntities(SpawnedEntities.TemplateID, MakeArrayView(&Entity, 1));
			// not using "RemoveAtSwap" on purpose to retain the order which will help creation of sparse chunks if need be
			SpawnedEntities.Entities.RemoveAt(Index, 1, /*bAllowShrinking=*/false);
			return true;
		}
	}
	return false;
}

void AMassSpawner::ClearTemplates()
{
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->GetConfig().DestroyEntityTemplate(*this, *EntityConfig);
		}
	}
}

void AMassSpawner::UnloadConfig()
{
	// Clear all templates that were created by the config
	ClearTemplates();
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		EntityType.UnloadEntityConfig();
	}

	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		StreamingHandle->CancelHandle();
	}
}

void AMassSpawner::OnAdjustTickSchematics(UWorld* World,TArray<TSoftObjectPtr<UMassSchematic>>& InOutTickSchematics)
{
	// this function gets called from a static multicast delegate, so we need to differentiate based on the World it's being called for.
	if (World != GetWorld())
	{
		return;
	}

	if (bOverrideSchematics)
	{
		UE_VLOG_UELOG(World, LogMassSpawner, Log, TEXT("Overriding TickSchematics with %s"), *GetName());
		InOutTickSchematics = TickSchematics;
	}
	else
	{
		UE_VLOG_UELOG(World, LogMassSpawner, Log, TEXT("Appending to TickSchematics with %s"), *GetName());
		InOutTickSchematics.Append(TickSchematics);
	}
}

